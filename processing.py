"""Script for processing steganographically-encoded images."""

import argparse
import PIL
import os
import sys

RGB_RANGE = 0b11111111


def image_apply(image, function):
    # type: PIL.Image, Callable[[int], int]
    """Applies a function to an image, returning the result as a new image.

    Args:
        image: The image to process.
        function: A function :: int -> int that takes a value \in [0, 256] and
            returns a new value \in [0, 265].
    """
    return PIL.Image.merge(
        'RGB', [channel.point(function) for channel in image.split()])


def least_significant_digits(pixel_value, n_significant_digits=None):
    # type: int -> int
    """Returns the n least-significant-digits of pixel_value."""
    if not n_significant_digits:
        n_significant_digits = 2
    return pixel_value & int('1' * n_significant_digits, base=2)


def normalize_to_rgb(value, n_significant_digits=None):
    # type: (int, int) -> int
    """Normalizes an int value \in [0, n_significant_digits) to RGB."""
    if not n_significant_digits:
        n_significant_digits = 4
    return value * int(float(RGB_RANGE) / n_significant_digits)


def apply_function_and_normalize_to_rgb(function, n_significant_digits):
    # type: (Callable[[int, int], int], int) -> Callable[int, int]
    """Composes a function which takes a pixel and applies function to it."""
    def inner(pixel_value):
        return normalize_to_rgb(
            function(pixel_value, n_significant_digits),
            n_significant_digits)
    return inner


def process(image_filename, least_significant_digit_interval):
    # type: (str, Tuple[int, int]) -> Dict[int, PIL.Image]
    """Runs an image through some steganographic decodings.

    Args:
        image_filename: The image to process. Totally blows up if this file
            doesn't exist. IDGAF!!!
        least_significant_digit_interval: An inverval of [int, int) over which
            to process the image.
    Returns:
        A map of least-significant-digit to post-processed image.
    """
    original_image = PIL.Image.open(image_filename)

    processed_images = {}
    for significant_digits in range(*least_significant_digit_interval):
        processed_images[significant_digits] = (
            image_apply(
                original_image,
                apply_function_and_normalize_to_rgb(
                    least_significant_digits,
                    int('1' * significant_digits, base=2))))
    return processed_images


def save(images, output_dir):
    # type: Dict[int, PIL.Image] -> None
    """Saves images with filenames showing the significant digit processed."""
    for significant_digits, image in images.itervalues():
        filename = ('0b{}.jpg'.format('1' * significant_digis))
        image.save(filename)


def argument_parser():
    # type: () -> argparse.ArgumentParser
    """Returns a configured argparser.ArgumentParser for this program."""
    parser = argparse.ArgumentParser(
        description='Process an image to figure out if it contains ~*SECRETS*~',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    parser.add_argument(
        'image_name',
        type=str,
        help='The name of the image to process.')
    parser.add_argument(
        '--least_significant_digits',
        type=int,
        default=2,
        help='The highest number of least significant digits to scan over.')
    parser.add_argument(
        '--save_processed_images',
        action='store_true',
        help='Save the images generated by this script.')
    parser.add_argument(
        '--output_dir',
        type=str,
        default='.',
        help=(
            'Save the images generated by this script to a specific location. '
            'If not specified, the current working directory will be used.'))

    return parser


def query_user(question, default="no"):
    """Ask a yes/no question via raw_input() and return their answer.

    Copied from
    https://stackoverflow.com/questions/3041986/apt-command-line-interface-like-yes-no-input

    "question" is a string that is presented to the user.
    "default" is the presumed answer if the user just hits <Enter>.
        It must be "yes" (the default), "no" or None (meaning
        an answer is required of the user).

    The "answer" return value is True for "yes" or False for "no".
    """
    if default is None:
        prompt = ' [y/n] '
    elif default == 'yes':
        prompt = ' [Y/n] '
    elif default == 'no':
        prompt = ' [y/N] '
    else:
        raise ValueError("invalid default answer: '%s'" % default)

    response_to_bool_map = {
        'yes': True,
        'y': True,
        'no': False,
        'n': False
    }
    while True:
        sys.stdout.write(question + prompt)
        choice = raw_input().lower()
        if default is not None and choice == '':
            return response_to_bool_map[default]
        elif choice in response_to_bool_map:
            return response_to_bool_map[choice]
        else:
            sys.stdout.write(
                'Please respond with {}'.format(
                    response_to_bool_map.iterkeys()))


def main():
    args = argument_parser().parse_args()

    # type: Dict[int, PIL.Image]
    lsd_to_images_map = process(
        args.image_name, (2, args.least_significant_digits+1))

    # Display the processed images
    for _, image in lsd_to_images_map.iteritems():
        image.show()

    # Save the images, if the user wants us to
    if args.save_processed_images:
        user_response = (
            query_user(
                'GONNA SAVE {} IMAGES GAR, IS THAT K???'.format(
                    len(lsd_to_images_map))))
        if user_response:
            save(lsd_to_images_map, output_dir=args.output_dir)


if __name__ == '__main__':
    main()
